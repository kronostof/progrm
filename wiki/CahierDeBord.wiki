#summary Cahier de bord.
#labels Featured



= Pour demain =

++Rajouter les dates au cahier de bord et le compéter.<br>
++Ajouter l'interface graphique.<br>

= Hitorique=


+Enchaîner une dizaine de module avec une traitement représentatif.<br>

Grosse frayeur avec cinq module le processeur dérouille.En cherchant l'origine du probleme on en optimise le code.
la partie 
{{{

abstract class Flux<E extends Information> extends Thread`*`(
	...
	abstract public void set(E fe);
	...
}}}
Est un non sens.on ne recree pas un obj pour l'inserer ds le flux destionnataire.
Ce sera	
{{{

abstract class Flux<E extends Information> extends Thread`*`(
	...
        abstract public void set(_liste dargument qui va bien pour modifier le champs data du flux_);
	...
}}}
Si pour cinq module on sens la différence...

Comme en c# c'est l'affichage qui  coince, sans afficher a chaque nouvel element ds le fulx ça passe En même temps 5*toString a 50hz fallait s'y attendre,non?<br>
oki: 30 module en parallèles les module déterminent si on regarde ou non une région ( chaque forme aura son module).

On introduit la notion de upToDate pour le chainnage en série de demain ( ou comment faire la différance entre une donnée et une donnée périmer.Il faudra faire passer ça dans la partie recevant le flux pour que plusieurs mod travaillant sur le même flux puissent le percevoir différement.

=== Grosse mise a plat ===

On réfléchit, on respire, on ce détend.<br>
Notion de UpToDate a cristalliser ds les commentaire et la doc.<br>
La classe lecteur se spécialise dans la récuperation des coordonnée par souris(socket plus tard), la classe Fluxposition retourne a qlq ch de plus rationnel ( plus de lireMouse 8O, Flux n'est plus _runnable_)<br>
Élagage de code en masse<br>

===Mise a plat===
On repare sur de bonne base. Un module sera une classe et non trois 8O<br>
En plus ça marche ! ! !
===Esper plusieurs modules===
premier jet de code, ça marche mais c'est vachement flou tout ça !<br>
On a 
-une classe pour un évenement<br>
-une classe qui écoute<br>
-une classe qui envoie tout les événement <br>
===J'Esper que ça marche===
===Esper utilisation===

===Esper===
Passage a Esper, parce que jamais tu désEspere.<br>
La phrase <br>_Esper and NEsper enable rapid development of applications that process large volumes of incoming messages or events. Esper and NEsper filter and analyze events in various ways, and respond to conditions of interest in real-time_<br>
A Quelque chose de rassurant,non?<br>
<br>
L'utilisation du langage java n'est finalement pas un frein pour la conception d'un programme a haute charge par unitée de temps =>c'est parti pour du java.

<a href=http://esper.codehaus.org>site officiel</a>

===NEsper===
Le développement du projet début en c#. A la recherche de code, d'info et de ressource sur les CEP et ESP, On s'orriente vers NEsper... jusqu'a se rendre compte que 
<li><a href="http://esper.codehaus.org/tutorials/faq_nesper/faq.html#multithread-safety">Le support du multithread était assez récent pour ne pas en parler possitivement</a>
<li><a href="http://esper.codehaus.org/tutorials/faq_nesper/faq.html#tested_on_OS">l'espace d'expression était assez réduit</a>


=== open-esb ===
Un site désesperément lent peu nuir!<br>
Apparement se qu'il nous faut ( si on avait beaucoup, beaucoup, de temps) Mais en java.
<a href=https://open-esb.dev.java.net/AboutOpenEsb.html> si vous avez du temps </a>

=== tripatouillage ===

<li> On va pouvoir commencer a travailler.
<li> joujou avec l'interface graphique on affiche un truc moche :p
<li> joujou avec bout de code N°2 modification interface on commande la machine a distance.
<li> joujou avec bout de code fourni par le fournisseur de l occulo qui ne fait pas grand chose,en c++ et c# On part sur du c#.
<li> joujou avec l'occulomètre (sans le casser) configuration,test,comment ça marche ...